// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: request.proto

#ifndef PROTOBUF_INCLUDED_request_2eproto
#define PROTOBUF_INCLUDED_request_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "capsule.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_request_2eproto 

namespace protobuf_request_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_request_2eproto
namespace capsule {
class ClientGetRequest;
class ClientGetRequestDefaultTypeInternal;
extern ClientGetRequestDefaultTypeInternal _ClientGetRequest_default_instance_;
class ClientGetResponse;
class ClientGetResponseDefaultTypeInternal;
extern ClientGetResponseDefaultTypeInternal _ClientGetResponse_default_instance_;
class FreshHashesContainer;
class FreshHashesContainerDefaultTypeInternal;
extern FreshHashesContainerDefaultTypeInternal _FreshHashesContainer_default_instance_;
}  // namespace capsule
namespace google {
namespace protobuf {
template<> ::capsule::ClientGetRequest* Arena::CreateMaybeMessage<::capsule::ClientGetRequest>(Arena*);
template<> ::capsule::ClientGetResponse* Arena::CreateMaybeMessage<::capsule::ClientGetResponse>(Arena*);
template<> ::capsule::FreshHashesContainer* Arena::CreateMaybeMessage<::capsule::FreshHashesContainer>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace capsule {

// ===================================================================

class ClientGetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:capsule.ClientGetRequest) */ {
 public:
  ClientGetRequest();
  virtual ~ClientGetRequest();

  ClientGetRequest(const ClientGetRequest& from);

  inline ClientGetRequest& operator=(const ClientGetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientGetRequest(ClientGetRequest&& from) noexcept
    : ClientGetRequest() {
    *this = ::std::move(from);
  }

  inline ClientGetRequest& operator=(ClientGetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientGetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientGetRequest* internal_default_instance() {
    return reinterpret_cast<const ClientGetRequest*>(
               &_ClientGetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ClientGetRequest* other);
  friend void swap(ClientGetRequest& a, ClientGetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientGetRequest* New() const final {
    return CreateMaybeMessage<ClientGetRequest>(NULL);
  }

  ClientGetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientGetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientGetRequest& from);
  void MergeFrom(const ClientGetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientGetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string replyAddr = 2;
  void clear_replyaddr();
  static const int kReplyAddrFieldNumber = 2;
  const ::std::string& replyaddr() const;
  void set_replyaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_replyaddr(::std::string&& value);
  #endif
  void set_replyaddr(const char* value);
  void set_replyaddr(const char* value, size_t size);
  ::std::string* mutable_replyaddr();
  ::std::string* release_replyaddr();
  void set_allocated_replyaddr(::std::string* replyaddr);

  // bool fresh_req = 3;
  void clear_fresh_req();
  static const int kFreshReqFieldNumber = 3;
  bool fresh_req() const;
  void set_fresh_req(bool value);

  // bool metaonly_req = 4;
  void clear_metaonly_req();
  static const int kMetaonlyReqFieldNumber = 4;
  bool metaonly_req() const;
  void set_metaonly_req(bool value);

  // @@protoc_insertion_point(class_scope:capsule.ClientGetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr replyaddr_;
  bool fresh_req_;
  bool metaonly_req_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_request_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientGetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:capsule.ClientGetResponse) */ {
 public:
  ClientGetResponse();
  virtual ~ClientGetResponse();

  ClientGetResponse(const ClientGetResponse& from);

  inline ClientGetResponse& operator=(const ClientGetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientGetResponse(ClientGetResponse&& from) noexcept
    : ClientGetResponse() {
    *this = ::std::move(from);
  }

  inline ClientGetResponse& operator=(ClientGetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientGetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientGetResponse* internal_default_instance() {
    return reinterpret_cast<const ClientGetResponse*>(
               &_ClientGetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ClientGetResponse* other);
  friend void swap(ClientGetResponse& a, ClientGetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientGetResponse* New() const final {
    return CreateMaybeMessage<ClientGetResponse>(NULL);
  }

  ClientGetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientGetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientGetResponse& from);
  void MergeFrom(const ClientGetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientGetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes fresh_hashes = 6;
  int fresh_hashes_size() const;
  void clear_fresh_hashes();
  static const int kFreshHashesFieldNumber = 6;
  const ::std::string& fresh_hashes(int index) const;
  ::std::string* mutable_fresh_hashes(int index);
  void set_fresh_hashes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fresh_hashes(int index, ::std::string&& value);
  #endif
  void set_fresh_hashes(int index, const char* value);
  void set_fresh_hashes(int index, const void* value, size_t size);
  ::std::string* add_fresh_hashes();
  void add_fresh_hashes(const ::std::string& value);
  #if LANG_CXX11
  void add_fresh_hashes(::std::string&& value);
  #endif
  void add_fresh_hashes(const char* value);
  void add_fresh_hashes(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fresh_hashes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fresh_hashes();

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string targetAddr = 4;
  void clear_targetaddr();
  static const int kTargetAddrFieldNumber = 4;
  const ::std::string& targetaddr() const;
  void set_targetaddr(const ::std::string& value);
  #if LANG_CXX11
  void set_targetaddr(::std::string&& value);
  #endif
  void set_targetaddr(const char* value);
  void set_targetaddr(const char* value, size_t size);
  ::std::string* mutable_targetaddr();
  ::std::string* release_targetaddr();
  void set_allocated_targetaddr(::std::string* targetaddr);

  // .capsule.CapsulePDU record = 3;
  bool has_record() const;
  void clear_record();
  static const int kRecordFieldNumber = 3;
  private:
  const ::capsule::CapsulePDU& _internal_record() const;
  public:
  const ::capsule::CapsulePDU& record() const;
  ::capsule::CapsulePDU* release_record();
  ::capsule::CapsulePDU* mutable_record();
  void set_allocated_record(::capsule::CapsulePDU* record);

  // bool success = 1;
  void clear_success();
  static const int kSuccessFieldNumber = 1;
  bool success() const;
  void set_success(bool value);

  // bool fresh_resp = 5;
  void clear_fresh_resp();
  static const int kFreshRespFieldNumber = 5;
  bool fresh_resp() const;
  void set_fresh_resp(bool value);

  // @@protoc_insertion_point(class_scope:capsule.ClientGetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fresh_hashes_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr targetaddr_;
  ::capsule::CapsulePDU* record_;
  bool success_;
  bool fresh_resp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_request_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FreshHashesContainer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:capsule.FreshHashesContainer) */ {
 public:
  FreshHashesContainer();
  virtual ~FreshHashesContainer();

  FreshHashesContainer(const FreshHashesContainer& from);

  inline FreshHashesContainer& operator=(const FreshHashesContainer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FreshHashesContainer(FreshHashesContainer&& from) noexcept
    : FreshHashesContainer() {
    *this = ::std::move(from);
  }

  inline FreshHashesContainer& operator=(FreshHashesContainer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FreshHashesContainer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FreshHashesContainer* internal_default_instance() {
    return reinterpret_cast<const FreshHashesContainer*>(
               &_FreshHashesContainer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FreshHashesContainer* other);
  friend void swap(FreshHashesContainer& a, FreshHashesContainer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FreshHashesContainer* New() const final {
    return CreateMaybeMessage<FreshHashesContainer>(NULL);
  }

  FreshHashesContainer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FreshHashesContainer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FreshHashesContainer& from);
  void MergeFrom(const FreshHashesContainer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FreshHashesContainer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes fresh_hashes = 1;
  int fresh_hashes_size() const;
  void clear_fresh_hashes();
  static const int kFreshHashesFieldNumber = 1;
  const ::std::string& fresh_hashes(int index) const;
  ::std::string* mutable_fresh_hashes(int index);
  void set_fresh_hashes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_fresh_hashes(int index, ::std::string&& value);
  #endif
  void set_fresh_hashes(int index, const char* value);
  void set_fresh_hashes(int index, const void* value, size_t size);
  ::std::string* add_fresh_hashes();
  void add_fresh_hashes(const ::std::string& value);
  #if LANG_CXX11
  void add_fresh_hashes(::std::string&& value);
  #endif
  void add_fresh_hashes(const char* value);
  void add_fresh_hashes(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& fresh_hashes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_fresh_hashes();

  // @@protoc_insertion_point(class_scope:capsule.FreshHashesContainer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> fresh_hashes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_request_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ClientGetRequest

// bytes hash = 1;
inline void ClientGetRequest::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientGetRequest::hash() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetRequest.hash)
  return hash_.GetNoArena();
}
inline void ClientGetRequest::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:capsule.ClientGetRequest.hash)
}
#if LANG_CXX11
inline void ClientGetRequest::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:capsule.ClientGetRequest.hash)
}
#endif
inline void ClientGetRequest::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:capsule.ClientGetRequest.hash)
}
inline void ClientGetRequest::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:capsule.ClientGetRequest.hash)
}
inline ::std::string* ClientGetRequest::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:capsule.ClientGetRequest.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientGetRequest::release_hash() {
  // @@protoc_insertion_point(field_release:capsule.ClientGetRequest.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientGetRequest::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:capsule.ClientGetRequest.hash)
}

// string replyAddr = 2;
inline void ClientGetRequest::clear_replyaddr() {
  replyaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientGetRequest::replyaddr() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetRequest.replyAddr)
  return replyaddr_.GetNoArena();
}
inline void ClientGetRequest::set_replyaddr(const ::std::string& value) {
  
  replyaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:capsule.ClientGetRequest.replyAddr)
}
#if LANG_CXX11
inline void ClientGetRequest::set_replyaddr(::std::string&& value) {
  
  replyaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:capsule.ClientGetRequest.replyAddr)
}
#endif
inline void ClientGetRequest::set_replyaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  replyaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:capsule.ClientGetRequest.replyAddr)
}
inline void ClientGetRequest::set_replyaddr(const char* value, size_t size) {
  
  replyaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:capsule.ClientGetRequest.replyAddr)
}
inline ::std::string* ClientGetRequest::mutable_replyaddr() {
  
  // @@protoc_insertion_point(field_mutable:capsule.ClientGetRequest.replyAddr)
  return replyaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientGetRequest::release_replyaddr() {
  // @@protoc_insertion_point(field_release:capsule.ClientGetRequest.replyAddr)
  
  return replyaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientGetRequest::set_allocated_replyaddr(::std::string* replyaddr) {
  if (replyaddr != NULL) {
    
  } else {
    
  }
  replyaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), replyaddr);
  // @@protoc_insertion_point(field_set_allocated:capsule.ClientGetRequest.replyAddr)
}

// bool fresh_req = 3;
inline void ClientGetRequest::clear_fresh_req() {
  fresh_req_ = false;
}
inline bool ClientGetRequest::fresh_req() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetRequest.fresh_req)
  return fresh_req_;
}
inline void ClientGetRequest::set_fresh_req(bool value) {
  
  fresh_req_ = value;
  // @@protoc_insertion_point(field_set:capsule.ClientGetRequest.fresh_req)
}

// bool metaonly_req = 4;
inline void ClientGetRequest::clear_metaonly_req() {
  metaonly_req_ = false;
}
inline bool ClientGetRequest::metaonly_req() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetRequest.metaonly_req)
  return metaonly_req_;
}
inline void ClientGetRequest::set_metaonly_req(bool value) {
  
  metaonly_req_ = value;
  // @@protoc_insertion_point(field_set:capsule.ClientGetRequest.metaonly_req)
}

// -------------------------------------------------------------------

// ClientGetResponse

// bool success = 1;
inline void ClientGetResponse::clear_success() {
  success_ = false;
}
inline bool ClientGetResponse::success() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetResponse.success)
  return success_;
}
inline void ClientGetResponse::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:capsule.ClientGetResponse.success)
}

// bytes hash = 2;
inline void ClientGetResponse::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientGetResponse::hash() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetResponse.hash)
  return hash_.GetNoArena();
}
inline void ClientGetResponse::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:capsule.ClientGetResponse.hash)
}
#if LANG_CXX11
inline void ClientGetResponse::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:capsule.ClientGetResponse.hash)
}
#endif
inline void ClientGetResponse::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:capsule.ClientGetResponse.hash)
}
inline void ClientGetResponse::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:capsule.ClientGetResponse.hash)
}
inline ::std::string* ClientGetResponse::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:capsule.ClientGetResponse.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientGetResponse::release_hash() {
  // @@protoc_insertion_point(field_release:capsule.ClientGetResponse.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientGetResponse::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:capsule.ClientGetResponse.hash)
}

// .capsule.CapsulePDU record = 3;
inline bool ClientGetResponse::has_record() const {
  return this != internal_default_instance() && record_ != NULL;
}
inline const ::capsule::CapsulePDU& ClientGetResponse::_internal_record() const {
  return *record_;
}
inline const ::capsule::CapsulePDU& ClientGetResponse::record() const {
  const ::capsule::CapsulePDU* p = record_;
  // @@protoc_insertion_point(field_get:capsule.ClientGetResponse.record)
  return p != NULL ? *p : *reinterpret_cast<const ::capsule::CapsulePDU*>(
      &::capsule::_CapsulePDU_default_instance_);
}
inline ::capsule::CapsulePDU* ClientGetResponse::release_record() {
  // @@protoc_insertion_point(field_release:capsule.ClientGetResponse.record)
  
  ::capsule::CapsulePDU* temp = record_;
  record_ = NULL;
  return temp;
}
inline ::capsule::CapsulePDU* ClientGetResponse::mutable_record() {
  
  if (record_ == NULL) {
    auto* p = CreateMaybeMessage<::capsule::CapsulePDU>(GetArenaNoVirtual());
    record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:capsule.ClientGetResponse.record)
  return record_;
}
inline void ClientGetResponse::set_allocated_record(::capsule::CapsulePDU* record) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(record_);
  }
  if (record) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      record = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, record, submessage_arena);
    }
    
  } else {
    
  }
  record_ = record;
  // @@protoc_insertion_point(field_set_allocated:capsule.ClientGetResponse.record)
}

// string targetAddr = 4;
inline void ClientGetResponse::clear_targetaddr() {
  targetaddr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientGetResponse::targetaddr() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetResponse.targetAddr)
  return targetaddr_.GetNoArena();
}
inline void ClientGetResponse::set_targetaddr(const ::std::string& value) {
  
  targetaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:capsule.ClientGetResponse.targetAddr)
}
#if LANG_CXX11
inline void ClientGetResponse::set_targetaddr(::std::string&& value) {
  
  targetaddr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:capsule.ClientGetResponse.targetAddr)
}
#endif
inline void ClientGetResponse::set_targetaddr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  targetaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:capsule.ClientGetResponse.targetAddr)
}
inline void ClientGetResponse::set_targetaddr(const char* value, size_t size) {
  
  targetaddr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:capsule.ClientGetResponse.targetAddr)
}
inline ::std::string* ClientGetResponse::mutable_targetaddr() {
  
  // @@protoc_insertion_point(field_mutable:capsule.ClientGetResponse.targetAddr)
  return targetaddr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientGetResponse::release_targetaddr() {
  // @@protoc_insertion_point(field_release:capsule.ClientGetResponse.targetAddr)
  
  return targetaddr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientGetResponse::set_allocated_targetaddr(::std::string* targetaddr) {
  if (targetaddr != NULL) {
    
  } else {
    
  }
  targetaddr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), targetaddr);
  // @@protoc_insertion_point(field_set_allocated:capsule.ClientGetResponse.targetAddr)
}

// bool fresh_resp = 5;
inline void ClientGetResponse::clear_fresh_resp() {
  fresh_resp_ = false;
}
inline bool ClientGetResponse::fresh_resp() const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetResponse.fresh_resp)
  return fresh_resp_;
}
inline void ClientGetResponse::set_fresh_resp(bool value) {
  
  fresh_resp_ = value;
  // @@protoc_insertion_point(field_set:capsule.ClientGetResponse.fresh_resp)
}

// repeated bytes fresh_hashes = 6;
inline int ClientGetResponse::fresh_hashes_size() const {
  return fresh_hashes_.size();
}
inline void ClientGetResponse::clear_fresh_hashes() {
  fresh_hashes_.Clear();
}
inline const ::std::string& ClientGetResponse::fresh_hashes(int index) const {
  // @@protoc_insertion_point(field_get:capsule.ClientGetResponse.fresh_hashes)
  return fresh_hashes_.Get(index);
}
inline ::std::string* ClientGetResponse::mutable_fresh_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:capsule.ClientGetResponse.fresh_hashes)
  return fresh_hashes_.Mutable(index);
}
inline void ClientGetResponse::set_fresh_hashes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:capsule.ClientGetResponse.fresh_hashes)
  fresh_hashes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ClientGetResponse::set_fresh_hashes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:capsule.ClientGetResponse.fresh_hashes)
  fresh_hashes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ClientGetResponse::set_fresh_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fresh_hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:capsule.ClientGetResponse.fresh_hashes)
}
inline void ClientGetResponse::set_fresh_hashes(int index, const void* value, size_t size) {
  fresh_hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:capsule.ClientGetResponse.fresh_hashes)
}
inline ::std::string* ClientGetResponse::add_fresh_hashes() {
  // @@protoc_insertion_point(field_add_mutable:capsule.ClientGetResponse.fresh_hashes)
  return fresh_hashes_.Add();
}
inline void ClientGetResponse::add_fresh_hashes(const ::std::string& value) {
  fresh_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:capsule.ClientGetResponse.fresh_hashes)
}
#if LANG_CXX11
inline void ClientGetResponse::add_fresh_hashes(::std::string&& value) {
  fresh_hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:capsule.ClientGetResponse.fresh_hashes)
}
#endif
inline void ClientGetResponse::add_fresh_hashes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fresh_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:capsule.ClientGetResponse.fresh_hashes)
}
inline void ClientGetResponse::add_fresh_hashes(const void* value, size_t size) {
  fresh_hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:capsule.ClientGetResponse.fresh_hashes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ClientGetResponse::fresh_hashes() const {
  // @@protoc_insertion_point(field_list:capsule.ClientGetResponse.fresh_hashes)
  return fresh_hashes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ClientGetResponse::mutable_fresh_hashes() {
  // @@protoc_insertion_point(field_mutable_list:capsule.ClientGetResponse.fresh_hashes)
  return &fresh_hashes_;
}

// -------------------------------------------------------------------

// FreshHashesContainer

// repeated bytes fresh_hashes = 1;
inline int FreshHashesContainer::fresh_hashes_size() const {
  return fresh_hashes_.size();
}
inline void FreshHashesContainer::clear_fresh_hashes() {
  fresh_hashes_.Clear();
}
inline const ::std::string& FreshHashesContainer::fresh_hashes(int index) const {
  // @@protoc_insertion_point(field_get:capsule.FreshHashesContainer.fresh_hashes)
  return fresh_hashes_.Get(index);
}
inline ::std::string* FreshHashesContainer::mutable_fresh_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:capsule.FreshHashesContainer.fresh_hashes)
  return fresh_hashes_.Mutable(index);
}
inline void FreshHashesContainer::set_fresh_hashes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:capsule.FreshHashesContainer.fresh_hashes)
  fresh_hashes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FreshHashesContainer::set_fresh_hashes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:capsule.FreshHashesContainer.fresh_hashes)
  fresh_hashes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FreshHashesContainer::set_fresh_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fresh_hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:capsule.FreshHashesContainer.fresh_hashes)
}
inline void FreshHashesContainer::set_fresh_hashes(int index, const void* value, size_t size) {
  fresh_hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:capsule.FreshHashesContainer.fresh_hashes)
}
inline ::std::string* FreshHashesContainer::add_fresh_hashes() {
  // @@protoc_insertion_point(field_add_mutable:capsule.FreshHashesContainer.fresh_hashes)
  return fresh_hashes_.Add();
}
inline void FreshHashesContainer::add_fresh_hashes(const ::std::string& value) {
  fresh_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:capsule.FreshHashesContainer.fresh_hashes)
}
#if LANG_CXX11
inline void FreshHashesContainer::add_fresh_hashes(::std::string&& value) {
  fresh_hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:capsule.FreshHashesContainer.fresh_hashes)
}
#endif
inline void FreshHashesContainer::add_fresh_hashes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  fresh_hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:capsule.FreshHashesContainer.fresh_hashes)
}
inline void FreshHashesContainer::add_fresh_hashes(const void* value, size_t size) {
  fresh_hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:capsule.FreshHashesContainer.fresh_hashes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FreshHashesContainer::fresh_hashes() const {
  // @@protoc_insertion_point(field_list:capsule.FreshHashesContainer.fresh_hashes)
  return fresh_hashes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FreshHashesContainer::mutable_fresh_hashes() {
  // @@protoc_insertion_point(field_mutable_list:capsule.FreshHashesContainer.fresh_hashes)
  return &fresh_hashes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace capsule

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_request_2eproto
